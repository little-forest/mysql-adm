#!/bin/bash
#===============================================================================
# mysql-backup :
#===============================================================================

SCRIPT_BASE=`echo $(cd $(dirname $0); pwd)`
SCRIPT_NAME=`basename $0`

#-------------------------------------------------------------------------------
# User Configuration -----------------------------------------------------------
MYSQL_ROOT_PASS=
BACKUP_BASE=/backup
MYSQL=/usr/bin/mysql
MYSQLDUMP=/usr/bin/mysqldump
COMPRESS_PROG=/usr/bin/pigz
ARCHIVE_FILE_SUFFIX=.gz
DATE_FORMAT=+%Y%m%d
#-------------------------------------------------------------------------------

DUMP_OPT=(--lock-all-tables --hex-blob --add-drop-database --add-drop-table)
DUMP_OPT_INFORMATION_SCHEMA=""
DUMP_OPT_MYSQL=(--lock-all-tables --events)
TAR_OPT=(-c)

cat /proc/$$/cgroup | egrep -q '^[0-9]+:name=systemd:/system.slice'
[[ $? -eq 0 ]] && SYSTEMD_SLICE=yes

[[ "${SYSTEMD_SLICE}" != 'yes' ]] && __MSG_COL=70

#-------------------------------------------------------------------------------
#- common functions ------------------------------------------------------------

__setup_color() { #{{{
  local I
  local COLOR_MAP=(\
    BLACK 0 MAROON 1 GREEN 2 OLIVE 3 NAVY 4 PURPLE 5 TEAL 6 SILVER 7 GREY 8 \
    RED 9 LIME 10 YELLOW 11 BLUE 12 FUCHSIA 13 AQUA 14 WHITE 15 \
    MAGENTA 5 CYAN 6 MALIBU 74 PINK 218 ORANGE 214 DARK_ORANGE3 166 \
  )

  # export color map when `__COLOR_MAP` is defined
  [[ -v __COLOR_MAP ]] && __COLOR_MAP=("${COLOR_MAP[@]}")

  if [[ $- == *u* ]] && [[ `type -t __setup_color_prepare_empty` == 'function' ]]; then
    __setup_color_prepare_empty ${COLOR_MAP[@]}
  fi

  C_OFF=`tput sgr0`   # Reset attribute
  C_BOLD=`tput bold`  # Bold mode
  C_REV=`tput rev`    # Reverse mode
  C_UL=`tput smul`    # Underline mode

  for ((I=0; I<${#COLOR_MAP[@]}; I+=2)); do
    # echo "$I : ${COLOR_MAP[$I]} ${COLOR_MAP[(($I + 1))]}"
    eval "C_${COLOR_MAP[$I]}=\`tput setaf ${COLOR_MAP[(($I + 1))]}\`"
    eval "C_B_${COLOR_MAP[$I]}=\`tput bold\`\`tput setaf ${COLOR_MAP[(($I + 1))]}\`"
    eval "C_U_${COLOR_MAP[$I]}=\`tput smul\`\`tput setaf ${COLOR_MAP[(($I + 1))]}\`"
    eval "C_R_${COLOR_MAP[$I]}=\`tput bold\`\`tput rev\`\`tput setaf ${COLOR_MAP[(($I + 1))]}\`"
  done
}
#}}}

__show_ok() { #{{{
  [[ -n "${__SILENT}" ]] && return
  local COL
  [[ ! "$1" =~ [0-9]+ ]] && COL="${__MSG_COL}" || COL="$1" && shift 1
  local MSG="$1"

  [[ -n "${COL}" ]] && echo -en "\\033[${COL}G"
  echo -en " [ ${C_GREEN}OK${C_OFF}"
  [[ -n "${MSG}" ]] && echo " ] ${MSG}" || echo " ]"
}
#}}}

__show_failed() { #{{{
  [[ -n "${__SILENT}" ]] && return
  local COL
  [[ ! "$1" =~ [0-9]+ ]] && COL="${__MSG_COL}" || COL="$1" && shift 1
  local MSG="$1"

  [[ -n "${COL}" ]] && echo -en "\\033[${COL}G"
  echo -en " [ ${C_RED}FAILED${C_OFF}"
  [[ -n "${MSG}" ]] && echo " ] ${MSG}" || echo " ]"
}
#}}}

__show_info() { #{{{
  [[ -n "${__SILENT}" ]] && return
  [[ "$1" == "-n" ]] && echo -en "${C_CYAN}${2}${C_OFF}" || echo -e "${C_CYAN}${1}${C_OFF}"
}
#}}}

__show_warn() { #{{{
  echo -e "[${C_YELLOW}WARN${C_OFF}]  $1"
}
#}}}

__show_error() { #{{{
  echo -e "[${C_RED}ERROR${C_OFF}] $*" >&2
}
#}}}

__error_end() { #{{{
  __show_error "$*"; exit 1
}
#}}}

__script_end() { #{{{
  local FUNC
  while read FUNC; do
    $FUNC
  done < <(declare -F | sed -e 's/^declare -f //' | egrep '^__?script_end_.+' | sort)
}
trap '__script_end' EXIT
#}}}

__prepare_dir() { #{{{
  local DIR="$1"
  if [[ ! -d "$DIR" ]]; then
    mkdir -p "$DIR"
    [[ ! -d "$DIR" ]] && return 1
    return 0
  fi
  return 0
}
#}}}

#-------------------------------------------------------------------------------
#- functions -------------------------------------------------------------------

_usage() { #{{{
  local STATUS=0
  if [[ -n "$@" ]]; then
    __show_error "$@"
    STATUS=1
    echo
  fi
  local B=${C_B_MALIBU}
  echo -e "${B}usege :${C_OFF} ${SCRIPT_NAME} [--silent] [-h] [-d] -c CONF_FILE"
  cat <<EOM
  ${B}OPTIONS${C_OFF}
    ${B}--silent${C_OFF} will not display messages (for batch job)
    ${B}-c${C_OFF}       specify configuration file path
    ${B}-d${C_OFF}       dry run
    ${B}-h${C_OFF}       show this help
  
  ${B}CONFIGURATIONS${C_OFF}
    MYSQL_ROOT_PASS=**********   # required
    BACKUP_BASE=/backup
    MYSQL=/usr/bin/mysql
    MYSQLDUMP=/usr/bin/mysqldump
    COMPRESS_PROG=/usr/bin/pigz
    ARCHIVE_FILE_SUFFIX=.gz
    DATE_FORMAT=+%Y%m%d
EOM
  exit $STATUS
}
#}}}

_load_conf() { #{{{
  local CONF_FILE="$1"
  [[ -z "$CONF_FILE" ]] && __error_end "Configuration file is not specified."
  if [[ ! -f "${CONF_FILE}" ]]; then
    __error_end "Configuration file is not found. : ${CONF_FILE}"
  fi

  local PARAMS=(MYSQL_ROOT_PASS BACKUP_BASE MYSQL MYSQLDUMP)
  PARAMS+=(COMPRESS_PROG ARCHIVE_FILE_SUFFIX DATE_FORMAT)

  local PAT="^[ \t]*(`echo ${PARAMS[@]} | tr ' ' '|'`)="
  source <(egrep "${PAT}" "${CONF_FILE}")

  if [[ -z "${__SILENT}" ]]; then
    echo "Configuration file loaded. : `readlink -f $CONF_FILE`"
  fi
}
#}}}

_list_database() { #{{{
  ${MYSQL} -uroot -p${MYSQL_ROOT_PASS} <<<"show databases;" -N \
    | egrep -v '^(information_schema|performance_schema)$' \
    | xargs
}
#}}}

_script_end_cleanup() { #{{{
  [[ -d "${_BACKUP_TMP_DIR}" ]] && rm -rf "${_BACKUP_TMP_DIR}"
}
#}}}

#-------------------------------------------------------------------------------
#- Main process ----------------------------------------------------------------
#-------------------------------------------------------------------------------
__setup_color

#- Get options -----------------------------------------------------------------
[[ "$1" = "--silent" ]] && __SILENT=yes && shift
while getopts c:dh OPT; do
  case "$OPT" in
    c) CONF_FILE=$OPTARG
      ;;
    d) _DRY_RUN=yes
      ;;
    h|\?) _usage
      ;;
  esac
done
shift `expr $OPTIND - 1`

#- Load configuration file -----------------------------------------------------
_load_conf "${CONF_FILE}"

#- Check options ---------------------------------------------------------------
[[ ! "$MYSQL_ROOT_PASS" ]] && _usage "An environmental valiable MYSQL_ROOT_PASS is not set."
[[ -z "${MYSQL}" ]] && MYSQL=`which mysql 2> /dev/null`
[[ ! -x "${MYSQL}" ]] && __error_end "Unable to find mysql executable. : ${MYSQL}"

if [[ ! -x "$COMPRESS_PROG" ]]; then
  __show_warn "$COMPRESS_PROG is not found. Use gzip."
  COMPRESS_PROG=""
  TAR_OPT+=(-z)
  ARCHIVE_FILE_SUFFIX=.gz
fi
ARCHIVE_FILE=${BACKUP_BASE}/mysql/"mysql-`LANG=C date "${DATE_FORMAT}"`.tar${ARCHIVE_FILE_SUFFIX}"
TAR_OPT+=(-f ${ARCHIVE_FILE})

#- Main process ----------------------------------------------------------------

[[ "$_DRY_RUN" == 'yes' ]] && __show_info "[DRY-RUN]"

__show_info "Backup start." 

if [[ "${_DRY_RUN}" != 'yes' ]]; then
  DIR="`dirname $ARCHIVE_FILE`" 
  __prepare_dir "${DIR}" || __error_end "Unable to create directory. : ${DIR}"
fi
_BACKUP_TMP_DIR=`mktemp -d`
DUMP_STATUS=0


#-----------------------------------------------------------
# Dump each databases
#-----------------------------------------------------------
for DBNAME in `_list_database`; do
  BACKUP_SQL=${_BACKUP_TMP_DIR}/${DBNAME}.sql
  OPT=(-u root)
  if [[ "${_DRY_RUN}" != 'yes' ]]; then
    OPT+=(-p${MYSQL_ROOT_PASS})
  else
    OPT+=(-P)
  fi

  if [[ "$DBNAME" == "mysql" ]]; then
    OPT+=(${DUMP_OPT_MYSQL[@]})
  else
    OPT+=(${DUMP_OPT[@]})
  fi
  OPT+=(--databases ${DBNAME})

  if [[ -z "${__SILENT}" ]]; then
    echo -n "  Backup ${DBNAME} to ${BACKUP_SQL} ... "
  fi

  if [[ "$_DRY_RUN" == 'yes' ]]; then
    echo
    echo -e "  [${C_YELLOW}dry-run${C_OFF}] ${MYSQLDUMP} ${OPT[@]}"
    continue
  fi

  # do mysqldump
  ${MYSQLDUMP} ${OPT[@]} > ${BACKUP_SQL}
  RESULT=$?
  if [[ ${RESULT} -eq 0 ]]; then
    # check file size
    SIZE=`ls -l $BACKUP_SQL | awk '{print $5}'`
    if [[ $SIZE -ge 0 ]]; then
      __show_ok
    else
      __show_failed
      DUMP_STATUS=1
    fi
   else
     __show_failed
     DUMP_STATUS=1
   fi
done

#-----------------------------------------------------------
# Archive
#-----------------------------------------------------------

TAR_OPT+=(--use-compress-prog=${COMPRESS_PROG} *.sql)
# When dry-run mode exit here
if [[ "$_DRY_RUN" ]]; then
  __show_info -n "[DRY-RUN]"
  echo " Will be archived : tar ${TAR_OPT[@]}"
  exit 0
fi

if [[ "${DUMP_STATUS}" -eq 1 ]]; then
  __error_end "Failed to dump databases."
fi

# Archive
pushd ${_BACKUP_TMP_DIR} > /dev/null
[[ -z "${__SILENT}" ]] && echo "  Archiving... : $ARCHIVE_FILE"
tar ${TAR_OPT[@]}
popd > /dev/null

if [[ -e $ARCHIVE_FILE ]]; then
  __show_info "Backup was successfully completed. : ${ARCHIVE_FILE}"
  exit 0
else
  __show_error "Backup failed. : ${ARCHIVE_FILE}"
  exit 1
fi

# vim: ts=2 sw=2 sts=2 et nu foldmethod=marker
