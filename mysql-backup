#!/bin/bash
#===============================================================================
# mysql-backup :
# Date    :  2016/09/18 Start
# Copyright: Original code by Yusuke Komori.
#                       Copyright (c) 2016. Yusuke Komori, All rights reserved.
#===============================================================================

SCRIPT_BASE=`echo $(cd $(dirname $0); pwd)`
SCRIPT_NAME=`basename $0`

#-------------------------------------------------------------------------------
# User Configuration -----------------------------------------------------------
MYSQL_ROOT_PASS=
BACKUP_BASE=/backup
MYSQL=/usr/bin/mysql
MYSQLDUMP=/usr/bin/mysqldump
COMPRESS_PROG=/usr/bin/pigz
ARCHIVE_FILE_SUFFIX=.gz
DATE_FORMAT=+%Y%m%d
#-------------------------------------------------------------------------------

DUMP_OPT=(--lock-all-tables --hex-blob --add-drop-database --add-drop-table)
DUMP_OPT_INFORMATION_SCHEMA=""
DUMP_OPT_MYSQL=(--lock-all-tables --events)
TAR_OPT=c

_SYSLOG=

#-------------------------------------------------------------------------------
#- common functions ------------------------------------------------------------

__setupcolor() { #{{{
  local I
  local COLOR_MAP=(\
    BLACK 0 MAROON 1 GREEN 2 OLIVE 3 NAVY 4 PURPLE 5 TEAL 6 SILVER 7 GREY 8 \
    RED 9 LIME 10 YELLOW 11 BLUE 12 FUCHSIA 13 AQUA 14 WHITE 15 \
    MAGENTA 5 CYAN 6 PINK 218 ORANGE 214 DARK_ORANGE3 166 \
  )

  C_OFF=`tput sgr0`   # Reset attribute
  C_BOLD=`tput bold`  # Bold mode
  C_REV=`tput rev`    # Reverse mode
  C_UL=`tput smul`    # Underline mode

  for ((I=0; I<${#COLOR_MAP[@]}; I+=2)); do
    # echo "$I : ${COLOR_MAP[$I]} ${COLOR_MAP[(($I + 1))]}"
    eval "C_${COLOR_MAP[$I]}=\`tput setaf ${COLOR_MAP[(($I + 1))]}\`"
    eval "C_B_${COLOR_MAP[$I]}=\`tput bold\`\`tput setaf ${COLOR_MAP[(($I + 1))]}\`"
    eval "C_U_${COLOR_MAP[$I]}=\`tput smul\`\`tput setaf ${COLOR_MAP[(($I + 1))]}\`"
    eval "C_R_${COLOR_MAP[$I]}=\`tput bold\`\`tput rev\`\`tput setaf ${COLOR_MAP[(($I + 1))]}\`"
  done
}
#}}}

__syslog() { #{{{
  [[ "${_SYSLOG}" != 'yes' ]] && return
  [[ "${DRY_RUN}" == 'yes' ]] && return
  local TAG="${SCRIPT_NAME}"
  local PRIORITY=user.info
  logger -t "$TAG" -p "${PRIORITY}" "$@"
}
#}}}

__syslog2() { #{{{
  if [[ "${_SYSLOG}" == 'yes' ]]; then
    [[ -n "${DRY_RUN}" ]] && return
    [[ "$1" == '-n' ]] && shift 1
    local TAG="${SCRIPT_NAME}"
    local PRIORITY=user.info
    logger -t "$TAG" -p "${PRIORITY}" "$@"
  else
    if [[ "$1" == '-n' ]]; then
      shift 1
      [[ $# -gt 0 ]] && echo -n "$@" || cat
    else
      [[ $# -gt 0 ]] && echo "$@" || cat
    fi
  fi
}
#}}}

__show_ok() { #{{{
  [[ "${SILENT_MODE}" ]] && return
  echo -e "[ ${C_GREEN}OK${C_OFF} ]"
}
#}}}

__show_failed() { #{{{
  [ "${SILENT_MODE}" ] && return
  [[ "$1" && "$1" -gt 0 ]] && local RES_COL="$1" || local RES_COL="${RES_COL}"
  echo -en "\\033[${RES_COL}G"
  echo -en "[ ${C_RED}FAILED${C_OFF}"
  [ "$2" ] && echo " ]$2" || echo " ]"
}
#}}}

__show_info() { #{{{
  [[ -n "${SILENT_MODE}" ]] && return
  [[ "$1" == "-n" ]] && echo -en "${C_CYAN}${2}${C_OFF}" || echo -e "${C_CYAN}${1}${C_OFF}"
}
#}}}

__show_warn() { #{{{
  echo -e "[${C_YELLOW}WARN${C_OFF}]  $1"
}
#}}}

__show_error() { #{{{
  echo -e "[${C_RED}ERROR${C_OFF}] $@" >&2
  __syslog "[ERROR] $@"
}
#}}}

__error_end() { #{{{
  __show_error "$1"; exit 1
}
#}}}

__script_end() { #{{{
  [[ -d ${BACKUP_TMP_DIR} ]] && rm -rf ${BACKUP_TMP_DIR}
}
trap '__script_end' EXIT
#}}}

__prepare_dir() { #{{{
  local DIR="$1"
  if [[ ! -d "$DIR" ]]; then
    mkdir -p "$DIR"
    [[ ! -d "$DIR" ]] && return 1
    return 0
  fi
  return 0
}
#}}}

#-------------------------------------------------------------------------------
#- functions -------------------------------------------------------------------

_usage() { #{{{
  local STATUS=0
  if [[ -n "$@" ]]; then
    __show_error "$@"
    STATUS=1
    echo
  fi
  echo -e "${C_CYAN}usege :${C_OFF} $SCRIPT_NAME [--silent] [-h] [-d] -c CONF_FILE"
  cat <<EOM
  OPTIONS
    --silent will not display messages (for batch job)
    -c       specify configuration file path
    -d       dry run
    -h       show this help
  
  CONFIGURATIONS
    MYSQL_ROOT_PASS=**********   # required
    BACKUP_BASE=/backup
    MYSQL=/usr/bin/mysql
    MYSQLDUMP=/usr/bin/mysqldump
    COMPRESS_PROG=/usr/bin/pigz
    ARCHIVE_FILE_SUFFIX=.gz
    DATE_FORMAT=+%Y%m%d
EOM
  exit $STATUS
}
#}}}

_load_conf() { #{{{
  local CONF_FILE="$1"
  [[ -z "$CONF_FILE" ]] && __error_end "Configuration file is not specified."
  if [[ ! -f "${CONF_FILE}" ]]; then
    __error_end "Configuration file is not found. : ${CONF_FILE}"
  fi

  local PARAMS=(MYSQL_ROOT_PASS BACKUP_BASE MYSQL MYSQLDUMP)
  PARAMS+=(COMPRESS_PROG ARCHIVE_FILE_SUFFIX DATE_FORMAT)

  local PAT="^[ \t]*(`echo ${PARAMS[@]} | tr ' ' '|'`)="
  source <(egrep "${PAT}" "${CONF_FILE}")

  __syslog "Configuration file loaded. : `readlink -f $CONF_FILE`"
  [[ ! "${SILENT_MODE}" ]] && echo "Configuration file loaded. : `readlink -f $CONF_FILE`"
}
#}}}

_list_database() { #{{{
  ${MYSQL} -uroot -p${MYSQL_ROOT_PASS} <<<"show databases;" -N \
    | egrep -v '^(information_schema|performance_schema)$' \
    | xargs
}
#}}}

#-------------------------------------------------------------------------------
#- Main process ----------------------------------------------------------------
#-------------------------------------------------------------------------------
tty -s || _NO_TTY=yes
if [[ "${_NO_TTY}" == 'yes' ]]; then
  _SYSLOG=yes
else
  __setupcolor
fi

#- Get options -----------------------------------------------------------------
[[ "$1" = "--silent" ]] && SILENT_MODE=yes && shift
while getopts c:dh OPT; do
  case "$OPT" in
    c) CONF_FILE=$OPTARG
      ;;
    d) DRY_RUN=yes
      _SYSLOG=
      ;;
    h|\?) _usage
      ;;
  esac
done
shift `expr $OPTIND - 1`

#- Load configuration file -----------------------------------------------------
_load_conf "${CONF_FILE}"

#- Check options ---------------------------------------------------------------
[[ ! "$MYSQL_ROOT_PASS" ]] && _usage "An environmental valiable MYSQL_ROOT_PASS is not set."
[[ -z "${MYSQL}" ]] && MYSQL=`which mysql 2> /dev/null`
[[ ! -x "${MYSQL}" ]] && __error_end "Unable to find mysql executable. : ${MYSQL}"

if [[ ! -x "$COMPRESS_PROG" ]]; then
  __show_warn "$COMPRESS_PROG is not found. Use gzip."
  COMPRESS_PROG=""
  TAR_OPT="z${TAR_OPT}"
  ARCHIVE_FILE_SUFFIX=.gz
fi
TAR_OPT="${TAR_OPT}f"
ARCHIVE_FILE=${BACKUP_BASE}/mysql/"mysql-`LANG=C date "${DATE_FORMAT}"`.tar${ARCHIVE_FILE_SUFFIX}"

#- Main process ----------------------------------------------------------------

[[ "$DRY_RUN" == 'yes' ]] && __show_info "[DRY-RUN]"

__syslog "Backup start."
__show_info "Backup start."

if [[ "${DRY_RUN}" != 'yes' ]]; then
  DIR="`dirname $ARCHIVE_FILE`" 
  __prepare_dir "${DIR}" || __error_end "Unable to create directory. : ${DIR}"
  BACKUP_TMP_DIR=`mktemp -d`
fi
DUMP_STATUS=0


# Dump each databases
for DBNAME in `_list_database`; do
  BACKUP_SQL=${BACKUP_TMP_DIR}/${DBNAME}.sql
  OPT=(-u root)
  if [[ "${DRY_RUN}" != 'yes' ]]; then
    OPT+=(-p${MYSQL_ROOT_PASS})
  else
    OPT+=(-P)
  fi

  if [[ "$DBNAME" == "mysql" ]]; then
    OPT+=(${DUMP_OPT_MYSQL[@]})
  else
    OPT+=(${DUMP_OPT[@]})
  fi
  OPT+=(${DBNAME})


  __syslog "  Backup ${DBNAME} to ${BACKUP_SQL} ... "
  [[ ! "${SILENT_MODE}" ]] && echo -n "  Backup ${DBNAME} to ${BACKUP_SQL} ... "
  if [[ "$DRY_RUN" == 'yes' ]]; then
    echo
    echo -e "  [${C_YELLOW}dry-run${C_OFF}] ${MYSQLDUMP} ${OPT[@]}"
    continue
  fi

  ${MYSQLDUMP} ${OPT[@]} > ${BACKUP_SQL}
  RESULT=$?
  if [[ ${RESULT} -eq 0 ]]; then
    # check file size
    SIZE=`ls -l $BACKUP_SQL | awk '{print $5}'`
    if [[ $SIZE -ge 0 ]]; then
      __show_ok
      __syslog "  Dump $DBNAME successful."
    else
      __show_failed
      __syslog "  Dump $DBNAME failed."
      DUMP_STATUS=1
    fi
   else
     __show_failed
     __syslog "  Dump $DBNAME failed."
     DUMP_STATUS=1
   fi
done

# When dry-run mode exit here
if [[ "$DRY_RUN" ]]; then
  __show_info -n "[DRY-RUN]"
  echo " Will be archived : tar ${TAR_OPT} ${ARCHIVE_FILE} --use-compress-prog=${COMPRESS_PROG} *.sql"
  exit 0
fi

if [[ "${DUMP_STATUS}" -eq 1 ]]; then
  rm -rf $BACKUP_TMP_DIR
  __error_end "Failed to dump databases."
fi

# Archive
pushd $BACKUP_TMP_DIR > /dev/null
__syslog "  Archiving... : $ARCHIVE_FILE"
[[ ! ${SILENT_MODE} ]] && echo "  Archiving... : $ARCHIVE_FILE"
tar ${TAR_OPT} ${ARCHIVE_FILE} --use-compress-prog=${COMPRESS_PROG} *.sql
popd > /dev/null

rm -rf $BACKUP_TMP_DIR

if [[ -e $ARCHIVE_FILE ]]; then
  __show_info "Backup was successfully completed. : ${ARCHIVE_FILE}"
  __syslog "Backup was successfully completed. : ${ARCHIVE_FILE}"
  exit 0
else
  __show_error "Backup failed. : ${ARCHIVE_FILE}"
  __syslog "Backup failed. : ${ARCHIVE_FILE}"
  exit 1
fi

# vim: ts=2 sw=2 sts=2 et nu foldmethod=marker
